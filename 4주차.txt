데마 4주차
유니버셜 함수
numpy의 한 종류이다.

np.arange(10)
0~9

random.randn(8)
하면 8개의 랜덤값

np.modf(arr) 하면 정수와 실수 부분을 나눈 것이다.
그래서 
a, b = np.modf(arr)하면 실수는 a에 정수는 b에 저장이 된다.(배열형태)

np.sqrt(arr)하면 모든 인자에 루트

np.meshgrid는 두개의 1차원 배열을 받아서 모든 x,y 배열의 짝을 만든다.

{0,1,2,3,4,5} 라는 x 배열과
{0,1,2,3,4}라는 y 배열이 있다.
이것을 ㅡmeshgrid 하면 각각에 대응을 시킨다.

xs, ys = np.meshgrid(x,y)
xs 는 
[[0 1 2 3 4 5]
 [0 1 2 3 4 5]
 [0 1 2 3 4 5]
 [0 1 2 3 4 5]
 [0 1 2 3 4 5]]
ys 는
[[0 0 0 0 0 0]
 [1 1 1 1 1 1]
 [2 2 2 2 2 2]
 [3 3 3 3 3 3]
 [4 4 4 4 4 4]]

다음과 같이 결과가 나온다. 즉 서로 대응하게 만들어서 0,0부터 5,4까지 나오도록 매치시킨다고 보면 된다.



@배열 연산으로 조건절 표현
xarr = np.array([1.1, 1.2, 1.3, 1.4, 1.5])
yarr = np.array([2.1, 2.2, 2.3, 2.4, 2.5])
cond = np.array([True, False, True, True, False])

cond값이 트루일때 xarr값을 false일 때 yarr값을 
취한다.
우리가 원하는 결과는 
[1.1, 2.2, 1.3, 1.4, 2.5]

result = [(x if c else y) for x,y,c in zip(xarr,yarr, cond)]

아니면
result =  np.where(cond, xarr,yarr)
즉 cond가 참이면 xarr을 거짓이면 yarr을 가져와라 란 뜻이다.


@수학, 통계 메서드
mean() sum() 함수
mean()은 평균값
np.mean(arr) 또는 arr.mean()으로 사용 가능

sum() 모든 것을 더한 값
mean과 같이 np나 배열 뒤에 사용 가능

만약 괄호에 axis = 숫자로 축을 넣어주면
그 축들의 합을 출력 이것은 예제를 보는게 편함

axis 숫자는 행이 0 열이 1이다.

a = np.array([[3,4],[7,8],[1,2]])
print(a.sum(axis = 0)) #[11, 14] 
print(a.sum(axis = 1)) #[7, 15, 3] 
다음과 같이 나온다.
행값들을 더한다
열값들을 더한다.

arr.cumsum()은
0부터 n번째 까지 더한다.
즉 [0,1,2,3,4,5]
면
0 1 3 6 10 15
즉 그 인덱스 까지의 덧셈을 한다.

arr = np.random.randn(100)으로 하고
(arr>0)을 실행하면 100개의 참 거짓값이 나온다.
만약 (arr>0).sum()을 하면 참값의 개수를 가진다.
그래서 조건에 맞는것이 몇개인지 찾기 쉬움

.any() 의 경우 하나이상의 값이 참인지
.all() 의 경우 모든 원소가 참인지
불린 형태로 알려줌

sort() 가능
arr.sort(1)를 하면 같은 행 내에서 정렬을 한다
arr.sort(0)를 하면 같은 열 내에서 정렬을 한다

arr = np.array([[5,3,4],
                [6,1,7],
                [9,2,8]])
print(arr)
arr.sort(1)
print(arr)
arr.sort(0)
print(arr)

[[5 3 4]
 [6 1 7]
 [9 2 8]]
[[3 4 5]
 [1 6 7]
 [2 8 9]]
[[1 4 5]
 [2 6 7]
 [3 8 9]]

집합 관련 함수
np.unique(arr)
중복하지 않게 배열 생성.

values = np.array([6,0,0,3,2,5,6])
np.in1d(values , [2,3,6])
이렇게 하면 첫번째 배열의 원소가 두번째 배열의 원소로 포함하는지. 
[T, F,F,T,T,F,T]
이런식으로 나온다.

arr = np.arange(10)
np.save('some_array',arr)하면 디스크에 저장이 가능하다. npy라는 파일로 저장이 된다.
np.load('some_array.npy')로 불러올 수 있다.

np.savez('arr_archive.npz', a=arr, b=arr)처럼 여러개를 저장이 가능하다
불러와서 사용은
arch = np.load('some_array.npy')
arch['b'] 이런식으로 불러올 수 있다.

===============================

선형대수.

선형대수는 행렬곱과 행렬 원소곱이 있다
행렬 원소곱은 행렬끼리의 사이즈가 같아야함 즉
a와 b를 곱할 때 a가 3x4면 b도 3x4여야 함

행렬곱은 a가 3x4일 경우 b는 4xn값이어야 한다 즉 앞의 열과 뒤의 행의 크기가 같아야 한다.
그래서 행렬곱은 교환법칙이 성립 x

a.dot(b)형태로 사용하고 np.dot(a,b)로도 가능하다
@ 기호로도 사용이 가능하다(파이선 3.5부터)
np.ones(3)으로 생성된 것은 다른 경우(이건 백터의 형태? 나중에 알려줌)

역행렬. 
nxn 형태를 정방행렬이라고 한다.
A, B가 정방 행렬인 경우
AB =BA = I 
여기서 I는 대각선이 1인 경우 즉
[[100]
 [010]
 [001]] 형태이다 (n에 따라 크기는 달라짐)
역행렬을 구하는 것은
(역행렬을 B-1로 표기하겟음)
A@B = I
양변에 B-1을 곱함
그럼 A = I*B-1이 된다.

이걸 코드로 나타내면
X = np.random.randn(5,5)
mat = X.T.dot(X)
inv(mat)
mat.dot(inv(mat))

난수 생성
np.random
normal도 있고 randn도 있고 여러가지

samples = np.random.normal(size = (1000,1))
이것이 정규 분포로 만드는 것이다.
randn 역시 정규분포로 만들어진다.
정규분포는 가운데가 올라간 형태
그냥 rand는 균등 분포

반복문으로 사용하는 것보다 numpy를 사용하는게 더 빠름

난수 생성기는 np.random.seed(시드값)로 매번 실행해도 같은 랜덤값이 나오도록


고급 배열 조작기법
reshape를 이용해 새로운 모양을 나타내는 튜플로 넘기기

arr = np.arange(8)
arr
arr = arr.reshape((4,2))
해서 다르게 변경 할 수 있다.
reshape((4,2), order='C또는 F')
C는 
1234
5678
F는 
1357
2468
이렇게 저장

reshape(5,-1)하면 -1은 배열의 원소개수에 맞게 적절하게 배분한다. 원소가 15개면 -1부분이 3크기에 맞춰진다.
다차원을 다시 낮은 차원으로 평탄화하려면
arr.ravel()
5x3의 형태를 ravel 하면
1x15형태로 바꾼다.
ravel() 말고 arr.flatten()도 가능.

행렬을 더 늘리거나 다른 행렬을 붙이고 싶을 때.
arr1 ,2 둘다 2x3일때
np.concatenate([arr1, arr2], axis = 0) 행을 늘림
np.concatenate([arr1, arr2], axis = 1) 열을 늘림
행을 늘리면 4x3이 되고
열을 늘리면 2x6이 된다.

split
배열을 축을 따라 여러개의 배열로 나눌 수 있다.

arr= np.random.randn(5,2)
first, second, third = np.split(arr,[2,3])
2번째와 3번째에 나누겟다.
즉
arr
[[1,2]
 [3,4]
 [5,6]
 [7,8]
 [9,10]]
있다면 
[[1,2]
 [3,4]] 가 first
[[5,6]] 이 second
나머지가 third로 나눠진다.


반복 엘리먼트
repeat과 tile이 있다
arr =  np.arange(4).reshape(2,2)
arr.repeat(2, axis = 0) 하면
[[0,1]
 [0,1]
 [2,3]
 [2,3]]
이렇게 나온다.

tile의 경우는 블럭을 붙인다.
np.tile(arr,(2,1))
[[0,1]
 [2,3]
 [0,1]
 [2,3]]
옆으로 붙이려면
np.tile(arr,(1,2))
즉 arr을 하나의 블럭으로 생각해서 행에 1개 열에 2개를 붙이겟단 뜻 같다
( (3,2)로 하면
[[0 1 0 1]
 [2 3 2 3]
 [0 1 0 1]
 [2 3 2 3]
 [0 1 0 1]
 [2 3 2 3]]
이런식으로 나온다)


브로드캐스팅
연산을 하고자하는 배열의 사이즈가 같지 않아도 수행될 수 있도록 한다.

(4,3)의 행렬과 (3,)의 행렬이 있다.
여기서 (3,)는 (3,1)이 아니라 
[1,2,3] 이런 형태로 생성되어 있다고 한다
브로드 캐스팅을 하면
[[1,2,3]
 [1,2,3]
 [1,2,3]
 [1,2,3]] 형태로 만들어준다.

예시를 보면
arr1 = np.around(np.random.randn(4,3)*10)
arr2 = np.around(np.random.randn(3,)*10)
하면 arr1 (4,3) 이고 arr2 (3,)이다
arr1
[[1,2,3],
 [5,6,7],
 [9,10,11]
 [13,14,15]]

arr2
[1,2,3]
이렇게 만들어 졋다고 보면 된다

arr1 + arr2를 하면
[[2,4,6],
 [6,8,10],
 [10,12,14],
 [14,15,18]]
이런 결과가 나온다.

arr2 =arr1.mean(1)로 하면 (4,)형태로 만들어 진다. (열의 평균값을 내기 때문에)
그러면 arr2를 브로드 캐스팅 해도 (4,4)가 되어 arr1과 연산이 불가능하다. 즉 열 값이 다르기 때문에 안된다.
이럴 경우 arr2.reshape(4,1)을 해준다면 
(4,3)형태로 브로드캐스팅 해서 연산이 가능해진다.

즉 브로드캐스팅 하기 위해서
2차원의 경우
arr1이 (n,m) 일 때
arr2가 (m, ) (행으로 복사) 거나 (n,1) (열로 복사)일 때 가능하다

3차원의 경우
arr1 (n,m,k)일 때
arr2는 
(m,k, )일 때 가능하다(면으로 복사)





